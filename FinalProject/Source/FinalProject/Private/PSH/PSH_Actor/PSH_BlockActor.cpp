// Fill out your copyright notice in the Description page of Project Settings.


#include "PSH/PSH_Actor/PSH_BlockActor.h"
#include "PhysicsEngine/PhysicsHandleComponent.h"
#include "Kismet/KismetMathLibrary.h"
#include "Kismet/KismetArrayLibrary.h"

// Sets default values
APSH_BlockActor::APSH_BlockActor()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	meshComp = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Mesh"));
	SetRootComponent(meshComp);
}

// Called when the game starts or when spawned
void APSH_BlockActor::BeginPlay()
{
	Super::BeginPlay();
	
	meshComp->OnComponentSleep.AddDynamic(this, &APSH_BlockActor::OnComponentSleep);
}

// Called every frame
void APSH_BlockActor::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

// 	if (bGrab) // true 일떄
// 	{
// 		FVector worldLoc; // 마우스의 월드 포지션
// 		FVector worldDir; // 카메라 포지션과 마우스 클릭 장소간의 방향
// 
// 		APlayerController* pc = Cast<APlayerController>(GetOwner());
// 		UE_LOG(LogTemp, Warning, TEXT("%s"), *GetOwner()->GetName());
// 
// 		if (pc == nullptr) return;
// 		pc->DeprojectMousePositionToWorld(worldLoc, worldDir);
// 
// 		/*UE_LOG(LogTemp, Warning, TEXT("X : %f Y : %f Z : %f"), worldLoc.X, worldLoc.Y, worldLoc.Z);*/
// 		FVector TargetLocation = worldLoc + (worldDir * 200.0f); // 약간 앞쪽으로 이동
// 
// 		playerHandle->SetTargetLocation(TargetLocation);
// 	}
}
void APSH_BlockActor::PickUp(class UPhysicsHandleComponent* handle)
{
	if (handle == nullptr) return;
	
	// 부모와의 연결 제거
	Remove();

	// 블록 잡기
	handle->GrabComponentAtLocationWithRotation(meshComp, NAME_None, GetActorLocation(), GetActorRotation());

	pickedUp = true;

	meshComp->SetCollisionResponseToChannel(ECC_PhysicsBody, ECR_Overlap);
	meshComp->SetCollisionResponseToChannel(ECC_WorldStatic, ECR_Overlap);

	for (auto* actor : childsActors)
	{
		Cast<APSH_BlockActor>(actor)->ChildCollisionUpdate(ECollisionEnabled::QueryOnly);
	}
}

void APSH_BlockActor::Drop(class UPhysicsHandleComponent* physicshandle)
{
	if (physicshandle != nullptr)
	{
		physicshandle->ReleaseComponent();
	}
	
	pickedUp = false;

	meshComp->SetCollisionResponseToChannel(ECC_PhysicsBody, ECR_Block);
	meshComp->SetCollisionResponseToChannel(ECC_WorldStatic, ECR_Block);
	meshComp->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);

	for (auto* actor : childsActors)
	{
		Cast<APSH_BlockActor>(actor)->ChildCollisionUpdate(ECollisionEnabled::QueryAndPhysics);
	}
}

void APSH_BlockActor::Place(class APSH_BlockActor* attachActor, FTransform worldTransform)
{
	if (GEngine)
		GEngine->AddOnScreenDebugMessage(-1, 15.f, FColor::Red, FString(TEXT("Pickup Dev")));

	
	attachActor->AddChild(this); // 부모 블록에 자식 블록으로 추가

	FAttachmentTransformRules rule = FAttachmentTransformRules(EAttachmentRule::KeepWorld, EAttachmentRule::SnapToTarget, EAttachmentRule::KeepWorld, true);
	// 부모 브럵에 붙이기
	this->AttachToActor(attachActor, rule);

	meshComp->SetSimulatePhysics(false);
	parent = attachActor;

	// 자식 블록의 위치와 방향을 변경
	SetActorRelativeLocation(worldTransform.GetLocation());
	SetActorRotation(worldTransform.GetRotation());

	MyLocation = worldTransform;
	// 부모블록에 나의 자식 블록들 전송
	attachActor->TransferChildren(childsActors);

	meshComp->SetCollisionResponseToChannel(ECC_PhysicsBody, ECR_Block);
	meshComp->SetCollisionResponseToChannel(ECC_WorldStatic, ECR_Block);
	meshComp->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);

	for (auto* actor : childsActors)
	{
		Cast<APSH_BlockActor>(actor)->ChildCollisionUpdate(ECollisionEnabled::QueryAndPhysics);
	}
}

void APSH_BlockActor::Remove()
{

	if(parent == nullptr) return;
	
	// 부모에서 분리
	FDetachmentTransformRules rule = FDetachmentTransformRules::KeepWorldTransform;
	DetachFromActor(rule);

	// 시물레이션 활성화
	meshComp->SetSimulatePhysics(true);

	// 부모에서 자식 제거
	parent->RemoveChild(this);
	parent->RemoveChildren(childsActors);
	
	parent = nullptr;
}

void APSH_BlockActor::RemoveChild(class APSH_BlockActor* actor)
{
	if (actor == nullptr) return;
	//자식 목록에서 제거
	if (childsActors.Contains(actor))  // 자식이 존재할 때만 제거
	{
		childsActors.Remove(actor);
	//	actor->parent = nullptr;  // 자식의 부모 제거
	}
}

void APSH_BlockActor::RemoveChildren(TArray<AActor*> childActor)
{
	if (childActor.IsEmpty()) return; // 배열이 비어있으면 검사x

	for (auto* actor : childActor)
	{
		if (Cast<APSH_BlockActor>(actor))
		{
			RemoveChild(Cast<APSH_BlockActor>(actor));
		}
		// 		childActor.Remove(Cast<APSH_BlockActor>(actor));
		// 		Cast<APSH_BlockActor>(actor)->parent = nullptr;
	}


}

void APSH_BlockActor::ChildCollisionUpdate(ECollisionEnabled::Type NewType) // 자식 콜리전 업데이트
{
	meshComp->SetCollisionEnabled(NewType);

	ECollisionResponse newResponse = ECR_Ignore;

	switch (NewType)
	{
	case ECollisionEnabled::NoCollision:
		newResponse = ECR_Overlap;
		pickedUp = true;
		break;
	case ECollisionEnabled::QueryOnly:
		newResponse = ECR_Overlap;
		pickedUp = true;
		break;
	case ECollisionEnabled::PhysicsOnly:
		newResponse = ECR_Ignore;
		pickedUp = false;
		break;
	case ECollisionEnabled::QueryAndPhysics:
		newResponse = ECR_Block;
		pickedUp = false;
		break;
	case ECollisionEnabled::ProbeOnly:
		newResponse = ECR_Ignore;
		pickedUp = false;
		break;
	case ECollisionEnabled::QueryAndProbe:
		newResponse = ECR_Ignore;
		pickedUp = false;
		break;
	}

	meshComp->SetCollisionResponseToChannel(ECC_PhysicsBody, newResponse);
	meshComp->SetCollisionResponseToChannel(ECC_WorldStatic, newResponse);


	for (auto* actor : childsActors)
	{
		Cast<APSH_BlockActor>(actor)->ChildCollisionUpdate(NewType);
	}
}

TArray<FVector> APSH_BlockActor::GetSnapPoints()
{
	return snapPoints;
}
TArray<FRotator> APSH_BlockActor::GetSnapDirections()
{
	return snapDirections;
}
TArray<int32> APSH_BlockActor::GetsnapPritority()
{
	return snapPritority;
}
void APSH_BlockActor::AddSnapPoint(FVector location, FRotator rotation, int32 priority)
{
	snapPoints.Add(location);
	snapDirections.Add(rotation);
	snapPritority.Add(priority);

	SnapApplyPriority();
}

void APSH_BlockActor::SnapApplyPriority()
{
	// Loop Through All Snap Points

	// 최소 2개의 우선순위가 있는지 확인
	if (snapPritority.Num() < 2) return;

	// 임시 배열 크기를 미리 설정
	TArray<FVector> tempSnapPoints;
	tempSnapPoints.SetNum(snapPoints.Num());

	TArray<FRotator> tempSnapDirections;
	tempSnapDirections.SetNum(snapDirections.Num());

	TArray<int32> tempSnapPritority;
	tempSnapPritority.SetNum(snapPritority.Num());

	for (int i = 0; i < snapPritority.Num(); i++)
	{
		int32 minIndex = 0;
		int32 pilYoeObSeum = 0;

		// 최소 우선순위 찾기
		UKismetMathLibrary::MinOfIntArray(snapPritority, minIndex, pilYoeObSeum);

		// 배열 크기를 동적으로 조정 (Size to Fit 기능 구현)
		if (tempSnapPoints.Num() <= i)
		{
			tempSnapPoints.SetNum(i + 1);  // 배열 크기 맞추기
		}
		if (tempSnapDirections.Num() <= i)
		{
			tempSnapDirections.SetNum(i + 1);  // 배열 크기 맞추기
		}
		if (tempSnapPritority.Num() <= i)
		{
			tempSnapPritority.SetNum(i + 1);  // 배열 크기 맞추기
		}

		// 최소값에 해당하는 스냅 포인트 및 방향을 임시 배열에 복사
		if (snapPoints.IsValidIndex(minIndex))
		{
			tempSnapPoints[i] = snapPoints[minIndex];
		}
		if (snapDirections.IsValidIndex(minIndex))
		{
			tempSnapDirections[i] = snapDirections[minIndex];
		}
		if (snapPritority.IsValidIndex(minIndex))
		{
			tempSnapPritority[i] = snapPritority[minIndex];
		}

		// 최소값을 최대값으로 설정하여 이후 반복에서 제외
		if (snapPritority.IsValidIndex(minIndex))
		{
			snapPritority[minIndex] = 2147483647;  // int32 최대값
		}
	}

	// 배열 재할당
	snapPoints = tempSnapPoints;
	snapDirections = tempSnapDirections;
	snapPritority = tempSnapPritority;
}

bool APSH_BlockActor::OvelapChek()
{
	// 겹치는 액터들을 저장할 배열 선언
	TArray<AActor*> OutOverlappingActors;

	// 필터링할 클래스의 타입을 정의 모든 엑터 검사
	TSubclassOf<AActor> ClassFilter = AActor::StaticClass();

	// 현재 메쉬 컴포넌트와 겹치는 모든 액터를 찾음
	meshComp->GetOverlappingActors(OutOverlappingActors, ClassFilter);

	// 겹치는 액터가 없으면 유효한 배치로 간주
	 validPlacement = OutOverlappingActors.Num() == 0;

	// 자식 액터들에 대해 재귀적으로 겹침 검사
	for (auto* actor : childsActors)
	{
		if (actor == nullptr)
		{
			continue;  // Null 포인터가 있을 경우 건너뜀
		}

		APSH_BlockActor* target = Cast<APSH_BlockActor>(actor);

		if (target)
		{
			if (target->OvelapChek()) // true가 나오면 true로 씌워질 가능성이 있음으로 false로 바로 변수 할당.
			{
				validPlacement = false;
			}
		}
	}

	//return validPlacement; // 최종 결과 반환
	return true; // 매쉬 크기의 문제로 현제는 무조건 true 반환, 후에 변경.
}


void APSH_BlockActor::AddChild(class APSH_BlockActor* childActor)
{
	//자신에게 자식을 추가
	if (!childsActors.Contains(childActor)) // 중복 추가 방지
	{
		childsActors.Add(childActor);
		childActor->parent = this;  // 자식의 부모 설정
	}
}


void APSH_BlockActor::TransferChildren(TArray<AActor*> childActor)
{
	for (auto* actor : childActor)
	{
		if (Cast<APSH_BlockActor>(actor))
		{
			AddChild(Cast<APSH_BlockActor>(actor));
		}
	}
}

void APSH_BlockActor::OnComponentSleep(UPrimitiveComponent* SleepingComponent, FName BoneName)
{
		// 물리 컴포넌트를 깨우기 (Wake Rigid Body)
		SleepingComponent->WakeRigidBody(BoneName);

}

FPSH_ObjectData APSH_BlockActor::SaveBlockHierachy()
{
// 	FPSH_ObjectData BlockData;
// 
// 	BlockData.actorTransfrom = GetActorTransform(); // 부모의 위치값
// 	BlockData.actor = GetClass(); // 부모의 클래스
// 
// 	// 자식 블록들을 저장
// 	SaveBlock(BlockData);
// 	
// 	for (auto* actor : childsActors)
// 	{
// 		if (Cast<APSH_BlockActor>(actor))
// 		{
// 			RemoveChild(Cast<APSH_BlockActor>(actor));
// 		}
// 	}
// 
// 	return BlockData;

	FPSH_ObjectData Data;

	// 현재 블록의 정보 저장
	Data.actor = GetClass();
	Data.actorTransfrom = GetActorTransform();

	// 자식 블록들의 정보 저장
	if (childsActors.Num() > 0)
	{
		FPSH_Childdats ChildrenData;
		ChildrenData = SaveBlock();
		Data.childsData.Add(ChildrenData);
	}

	return Data;
}

// ex 최상단 , 자식 1, 자식 2 , 자식1-1,1-2, 자식2-1,2-2
FPSH_Childdats APSH_BlockActor::SaveBlock(/*FPSH_ObjectData& blockdata*/)
{ 
// 	if (childsActors.IsEmpty()) return; // 자식이 없음
// 
// 	for (auto* ChildBlock : childsActors) // 자식 의 수만큼 실행. 
// 	{
// 		APSH_BlockActor* block = Cast<APSH_BlockActor>(ChildBlock);
// 
// 		FPSH_ChildData childData;
// 		childData.actor = block->GetClass();
// 		childData.actorTransfrom = block->MyLocation;
// 
// 		FPSH_Childdats childDatas;
// 
// 		childDatas.childData.Add(childData);
// 		blockdata.childsData.Add(childDatas);
// 		if (block->childsActors.IsEmpty()) // 자식이 없다면
// 		{
// 			return;
// 		}
// 		else // 자식이 있다면.
// 		{
// 		
// 			block->SaveBlock(blockdata);
// 		}
// 
// // 		if (block)
// // 		{
// // 			blockdata.childData.Add(childData);  // 자식 블록 재귀 저장
// // 		}
// 	}

	FPSH_Childdats ChildrenData;

	for (auto* Child : childsActors)
	{
		APSH_BlockActor* ChildBlock = Cast<APSH_BlockActor>(Child);
		if (ChildBlock)
		{
			FPSH_ChildData SingleChildData;
			SingleChildData.actor = ChildBlock->GetClass();
			SingleChildData.actorTransfrom = ChildBlock->GetActorTransform();
			ChildrenData.childData.Add(SingleChildData);

			// 재귀적으로 자식의 자식들도 처리
			if (ChildBlock->childsActors.Num() > 0)
			{
				FPSH_Childdats SubChildrenData = ChildBlock->SaveBlock();
				FPSH_ObjectData ChildObjectData;
				ChildObjectData.childsData.Add(SubChildrenData);
			}
		}
	}

	return ChildrenData;
}


void APSH_BlockActor::LoadBlockHierarchy(const FPSH_ObjectData& Data, TSet<APSH_BlockActor*>& ProcessedBlocks)
{
	// 이미 처리한 블럭은 다시 처리하지 않습니다.
	if (ProcessedBlocks.Contains(this))
	{
		return;
	}

	// 현재 블럭을 처리 목록에 추가
	ProcessedBlocks.Add(this);

	// 블럭의 위치와 회전을 설정합니다.
	SetActorTransform(Data.actorTransfrom);
	

	// 자식 블럭들을 스폰하고 부모-자식 관계를 설정합니다.
// 	for (const FPSH_ChildData& ChildData : Data.childData)
// 	{
// 		if (ChildData.actor)
// 		{
// 			// 자식 블럭을 스폰합니다.
// 			FActorSpawnParameters SpawnParams;
// 			APSH_BlockActor* ChildBlock = GetWorld()->SpawnActor<APSH_BlockActor>(
// 				ChildData.actor, ChildData.actorTransfrom, SpawnParams);
// 
// 			if (ChildBlock)
// 			{
// 				// AttachToActor 대신 Place 함수 사용
// 				ChildBlock->Place(this, ChildData.actorTransfrom);
// // 				// 자식 블럭을 로드할 때, 이미 부모와 연결되었는지 확인하고, 부모 블럭으로 다시 돌아가는 루프를 방지합니다.
// // 				ChildBlock->LoadBlockHierarchy(Data, ProcessedBlocks);
//  			}
// 		}
// 	}

}
void APSH_BlockActor::LoadBlockHierarchy(const FPSH_ObjectData& Data)
{
	if (!Data.actor) return;

	// 메인 블록 생성
	APSH_BlockActor* MainBlock = GetWorld()->SpawnActor<APSH_BlockActor>(
		Data.actor,
		Data.actorTransfrom
	);

	if (!MainBlock) return;

	// 자식 블록들 생성
	for (const FPSH_Childdats& ChildrenData : Data.childsData)
	{
		for (const FPSH_ChildData& ChildData : ChildrenData.childData)
		{
			if (ChildData.actor)
			{
				APSH_BlockActor* ChildBlock = GetWorld()->SpawnActor<APSH_BlockActor>(
					ChildData.actor,
					ChildData.actorTransfrom
				);

				if (ChildBlock)
				{
					// 부모-자식 관계 설정
					MainBlock->AddChild(ChildBlock);

					// 물리 시뮬레이션 비활성화 (부모에 붙어있으므로)
					ChildBlock->meshComp->SetSimulatePhysics(false);
				}
			}
		}
	}

}